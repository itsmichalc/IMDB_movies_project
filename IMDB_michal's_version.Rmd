---
title: "IMDB- Data Analysis"
author: "Kirill Bulgakov, Michal Cohen and Shachar Schneider"
date: "June 2021"
output: 
  html_document: default
  pdf_document: default
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

![](movie_theater.jpg)
```{r libraries, message=FALSE, warning=FALSE, echo=FALSE}
library(tidyverse)
library(ggcorrplot)
library(gridExtra)
library(lmtest)
library(RColorBrewer)
library(dplyr)

```

# Introduction

In our project we will examine
[this](https://www.kaggle.com/harshitshankhdhar/imdb-dataset-of-top-1000-movies-and-tv-shows/download)
data set describing 1000 movies. This data set comes from the IMDB
website and it contains a great deal of intriguing information about
movies such as: popularity of genre, gross, IMDB rating, MetaScore etc.

# Goals

In our paper we will:

1. Tidy the data in so that we can work with it.

2. Make some visualizations on the data and show you some interesting facts about it.

3. Do some statistical models and make conclusions about the data.


# Tidying
Let's get to know our data set by looking at it briefly.

```{r, message=FALSE, warning=FALSE}
raw_data<-read.csv(file='C:/Users/bulga/Downloads/imdb_top_1000.csv')
glimpse(raw_data)

```

So we need to make some changes.
First, we want to tidy the database by dropping NA's and irrelevant
categories such as "Poster_Link" , "Certificate" and "Overview".

```{r dataset, message=FALSE, warning=FALSE}

clean_data = subset(raw_data, select = -c(Poster_Link, Certificate, Overview))%>% na.omit(clean_data$Gross,clean_data$No_of_Votes,clean_data$Meta_score,clean_data$IMDB_Rating,clean_data$Runtime)
view(clean_data)
```

Secondly, we want to make some more adjustments for us to be able to
work properly: we need to remove the word "min" from the Runtime
category, remove commas from the Gross and change the numeric
information from character to integer. In addition, we want to convert
the Meta Score number from dozens to units, in order to compare it with
the IMDB rating later.

```{r tidying of the dataset, message=FALSE, warning=FALSE}

clean_data$Runtime <-gsub(" min","",as.character(clean_data$Runtime))

clean_data$Gross <-gsub(",","",as.character(clean_data$Gross))

clean_data <- transform(clean_data, Runtime = as.integer(Runtime),
                        Released_Year = as.integer(Released_Year), Gross = as.integer(Gross),No_of_Votes = as.integer(No_of_Votes), IMDB_Rating=as.double(IMDB_Rating), Meta_score=as.double(Meta_score))

clean_data <- mutate(clean_data,Meta_score = Meta_score/10,Gross_in_millions = Gross/1000000,votes_in_thousands= No_of_Votes/1000)

```



Now let's look at the clean data.

```{r}
glimpse(clean_data) 
```

Much better.
We can see there are a total of 12 genres in the data. But some of the movies contain more than one genre:

```{r}
clean_data %>%
  group_by(Genre) %>%
  summarise()

```

In order to get a better view of the recurrence, we will extract and
organize each of the genres separately, present in a table, and conclude which are the most popular genres.

```{r}

Table_Comedy<-grepl("Comedy",clean_data$Genre)
Num_Comedy<-sum(Table_Comedy)

Table_Adventure<-grepl("Adventure",clean_data$Genre)
Num_Adventure<-sum(Table_Adventure)

Table_Drama<-grepl("Drama",clean_data$Genre)
Num_Drama<-sum(Table_Drama)

Table_Romance<-grepl("Romance",clean_data$Genre)
Num_Romance<-sum(Table_Romance)

Table_Crime<-grepl("Crime",clean_data$Genre)
Num_Crime<-sum(Table_Crime)

Table_Thriller<-grepl("Thriller",clean_data$Genre)
Num_Thriller<-sum(Table_Thriller)

Table_Horror<-grepl("Horror",clean_data$Genre)
Num_Horror<-sum(Table_Horror)

Table_Action<-grepl("Action",clean_data$Genre)
Num_Action<-sum(Table_Action)

Table_Mystery<-grepl("Mystery",clean_data$Genre)
Num_Mystery<-sum(Table_Mystery)

Table_Scifi<-grepl("Sci-Fi",clean_data$Genre)
Num_Scifi<-sum(Table_Scifi)

Table_Animation<-grepl("Animation",clean_data$Genre)
Num_Animation<-sum(Table_Animation)

Table_Family<-grepl("Family",clean_data$Genre)
Num_Family<-sum(Table_Family)

tab <- matrix(c(Num_Action,Num_Adventure, Num_Animation, Num_Comedy, Num_Crime, Num_Drama, Num_Family, Num_Horror
                , Num_Mystery, Num_Romance, Num_Scifi, Num_Thriller), ncol=1, byrow=TRUE)
colnames(tab) <- c('Frequency')
rownames(tab) <- c('action','adventure','animation', 'comedy', 'crime', 'drama', 'family', 'horror', 'mystery',
                   'romance', 'scifi', 'thriller')
tab <- as.table(tab)

genres_table<-as.data.frame(tab)
genres_table = subset(genres_table, select = -c(Var2))
genres_table <- mutate(genres_table, genre_name=Var1)
genres_table = subset(genres_table, select = -c(Var1))

```

# Visualization

Now we can take a look at the popularity of the genres.

```{r}
palette_Dark2 <- colorRampPalette(brewer.pal(8, "Dark2"))
ggplot(data=genres_table, aes(x=genre_name, y=Freq, fill=genre_name)) +
  geom_bar(stat="identity") +
  theme(axis.text.x=element_text(angle=45, hjust=1))+
  labs(x="Genre name", y="Frequency",
       title="Genres frequency summary")+scale_fill_manual(values = palette_Dark2(15))


```

As we can see, Drama movies are much more popular than the other genres.

After we examined the different movie genres, let's take a look at the distribution of our different variables:

```{r,message=FALSE, warning=FALSE}
p1 <-ggplot(clean_data, aes(x= votes_in_thousands)) +
  geom_histogram(bins=30, fill="Navy")
p2 <-ggplot(clean_data, aes(x= Gross_in_millions)) +
  geom_histogram(bins=30, fill="lightseagreen")
p3 <-ggplot(clean_data, aes(x=IMDB_Rating )) +
  geom_histogram(bins=30, fill="turquoise")
p4 <-ggplot(clean_data, aes(x=Meta_score )) +
  geom_histogram(bins=30, fill="slategray1")
p5 <-ggplot(clean_data, aes(x=Runtime )) +
  geom_histogram(bins=30, fill="blue")

grid.arrange(grobs= list(p1,p2,p3,p4,p5),
    fontface = 3, fontsize = 3,hjust = 1,x = 1)

```

By looking at the the visualizations so far we can give two graphical assumptions:
1. Drama is the most frequent genre.
2. The Number of Votes, Gross, and IMDB rating distribution looks similar. 

Now it's time to test our assumptions.


# Modelling

**paired t-test for IMDB & meta_score:**

*H0:* The average IMDB rating and the average MetaScore are equal.

*H1:* The average IMDB rating and the average MetaScore are not equal.

```{r,message=FALSE, warning=FALSE}
boxplot(clean_data$IMDB_Rating, clean_data$Meta_score,
        names = c("IMDB", "METASCORE"))

t.test(x = clean_data$IMDB_Rating,
       y = clean_data$Meta_score,
       paired = TRUE, alternative = "two.sided")
```

*Conclusion*
As we can see from the results, we found that in a confidence level of 95%, we reject the null hypothesis, IMDB rating and MetaScore means are not equal.


**Paired t-test for Gross income**

*H0:* Action is a more profitable genre then non-action movies.

*H1:* The average gross income of action & not action movies has the
same.

```{r, message=FALSE, warning=FALSE}
drama_v <- true_genres%>%filter(is_drama=="TRUE")
not_drama_v <- true_genres%>%filter(is_drama=="FALSE")

drama_v <- drama_v %>% arrange(desc(Gross)) %>% slice(1:150) 
not_drama_v <- not_drama_v %>% arrange(desc(Gross)) %>% slice(1:150)

boxplot(drama_v$Gross_in_millions, not_drama_v$Gross_in_millions,
        names = c("drama gernre", "not drama genre"))

t.test(x = drama_v$Gross_in_millions,
       y = not_drama_v$Gross_in_millions,
       paired = FALSE, alternative = "less")

```

*Conclusion*

As we can see from the results, although we thought that we found that
in a confidence level of 95%, we accept the null hypothesis, Action
Genre movies are more profitable than non-action genre movies.


## Multiple regression model

We will start with correlation check in order to see which variables are
associated to each other.

```{r, message=FALSE, warning=FALSE}
num_data = subset(clean_data, select = -c(Series_Title, Star1, Star2, Star3, Star4, Director, Gross, Genre, No_of_Votes ))%>%na.omit() 
cor_graph =  cor(num_data)
ggcorrplot(cor_graph, type = "upper", hc.order = TRUE, outline.col = "white",ggtheme = ggplot2::theme_gray,
           colors = c("lightskyblue","white","lightseagreen"))
```

We can see a strong correlation between the number of votes & Gross
(which makes sense because the more people watched the movie, the more
people ranked it). We have a strong correlation between IMDB rating & no
of votes as well. In addition as we saw in the visualizations, the distribution of those variables reminds each other.
Let us have a look at it:

```{r, message=FALSE, warning=FALSE}
votes_gross <- ggplot(num_data, aes(x=votes_in_thousands, y=Gross_in_millions)) +
  stat_smooth(col="royalblue1")
votes_IMDB <- ggplot(num_data, aes(x=votes_in_thousands, y=IMDB_Rating)) +
  stat_smooth(col="royalblue1")

grid.arrange(grobs= list(votes_gross,votes_IMDB), fontface = 3, fontsize = 3, hjust = 1, x = 1)
```

We saw that we have a correlation between the number of votes and IMDB
rating, and a correlation between the number of votes and Gross but with
more variance in the higher values. Now we will check the linear model
on the number of votes & Gross + IMDB rating:

```{r, message=FALSE, warning=FALSE}
linear_model <- lm(votes_in_thousands ~ Gross_in_millions+IMDB_Rating, data=num_data) 
summary(linear_model)
```

We can see we have around 60% of Adjusted R-squared. The adjusted
R-squared compares the explanatory power of regression models that
contain different numbers of predictors. To make it simple, the R-squared suggests that there is a prediction of 60% to number of votes of a movie by it's IMDB rating & Gross. 

Lets have a look at the multiple linear regression visualization:

```{r, message=FALSE, warning=FALSE}
linear_model %>%  ggplot(aes(y=.resid, x=.fitted))+
  geom_point(color="turquoise4")+
  stat_smooth(method = "lm",color="black")
```

The graph does not look homoscedastic. Why is that?

Let's try to understand. First, we need to have a look at whether our
residuals normally distributed:

```{r, message=FALSE, warning=FALSE}

residuals_qq<- linear_model %>% ggplot(aes(sample=.resid)) +
  geom_qq() + geom_qq_line(col="blue") +
  labs(title="Residuals QQ Plot")
residuals_qq

```

We can see from the QQ plot that our residuals do not distribute
normally.

Now let's make Breusch-Pagan Test for homoscedasticity of the data:

```{r, message=FALSE, warning=FALSE }
bptest(linear_model)
```

Result of p < 0.05 suggesting that our data is not homoscedastic.

*Conclusions*

In order to use our model for predicting model, a number of conditions
must exist: **homoscedasticity** of the data & **normally distributed**
residuals. Our data does not answer this conditions, so our model can
not be used as a predicting model.

# Sumarry


![](the_end.jpg){width=50%}
